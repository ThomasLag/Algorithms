#include <cstdio>
#include <vector>
#include <list>
#include <queue>

using namespace std;

int N, M, L, i, u, v, w, temp, sum;
vector< list< pair< int, int > > > E;
list< pair< int, int > >::iterator it;
priority_queue< pair< int, pair< int, int > > > q;
pair< int, int > top;
FILE *in = fopen( "leaves.in", "r" );
bool marked[ 1002 ], P[ 1002 ];

int main() {
    fscanf( in, "%i %i %i", &N, &M, &L );
    E.resize( N + 1 );

    for ( i = 0; i < M; ++i ) {
        fscanf( in, "%i %i %i", &u, &v, &w );
        --u;
        --v;
        E[ u ].push_back( make_pair( -w, v ) );
        E[ v ].push_back( make_pair( -w, u ) );
    }
    for ( i = 0; i < L; ++i ) {
        fscanf( in, "%i", &u );
        P[ u - 1 ] = 1;
    }
    for ( i = 0; i < N; ++i ) {
        printf( "%i\n", i + 1 );
        for ( it = E[ i ].begin(); it != E[ i ].end(); ++it ) {
            printf( "\t%i - %i\n", ( *it ).second + 1, ( *it ).first );
        }
    }

    marked[ 0 ] = 1;
    for ( it = E[ 0 ].begin(); it != E[ 0 ].end(); ++it ) {
        q.push( make_pair( ( *it ).first, make_pair( 0, ( *it ).second ) ) );
    }

    while ( !q.empty() ) {
        w = q.top().first;
        top = q.top().second;
        printf( "%i - %i\n", top.first + 1, top.second + 1 );
        q.pop();
        temp = sum;
        if ( !marked[ top.second ] ) {
            if ( P[ top.first ] ) {
                if ( P[ top.second ] ) {
                    if ( !marked[ top.first ] && !marked[ top.second ] ) {
                        if ( N == 2 ) {
                            sum += -w;
                        }
                    }
                }
                if ( !marked[ top.first ] )  {
                    sum += -w;
                }
            }
            else if ( P[ top.second ] ) {
                if ( !marked[ top.second ] ) {
                    sum += -w;
                }
            }
            else {
                sum += -w;
            }
            if ( temp != sum ) {
                printf( "check\n" );
                marked[ top.second ] = 1;
                for ( it = E[ top.second ].begin(); it != E[ top.second ].end(); ++it ) {
                    if ( !marked[ ( *it ).second ] ) {
                        q.push( make_pair( ( *it ).first, make_pair( top.second, ( *it ).second ) ) );
                    }
                }
            }
        }
    }

    printf( "%i\n", sum );

    return 0;
}
